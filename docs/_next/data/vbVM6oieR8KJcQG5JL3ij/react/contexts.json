{"pageProps":{"contexts":[{"id":"LanguageContext","group":"context","name":"LanguageContext","emoji":"üåê","code":"import {\n  createContext,\n  FC,\n  ReactNode,\n  useCallback,\n  useContext,\n  useMemo,\n  useState,\n} from 'react';\n\nexport enum Language {\n  English = 'en',\n  Spanish = 'es',\n  French = 'fr',\n  German = 'de',\n  Italian = 'it',\n  Portuguese = 'pt',\n  Russian = 'ru',\n  ChineseSimplified = 'zh',\n  ChineseTraditional = 'zh-TW',\n  Japanese = 'ja',\n  Korean = 'ko',\n  Arabic = 'ar',\n  Hindi = 'hi',\n  Vietnamese = 'vi',\n  Dutch = 'nl',\n  Greek = 'el',\n  Turkish = 'tr',\n  Polish = 'pl',\n  Hebrew = 'he',\n  Swedish = 'sv',\n  Danish = 'da',\n  Norwegian = 'no',\n  Finnish = 'fi',\n  Thai = 'th',\n  Indonesian = 'id',\n  Malay = 'ms',\n  Czech = 'cs',\n  Hungarian = 'hu',\n  Romanian = 'ro',\n  Ukrainian = 'uk',\n  Persian = 'fa',\n}\n\ntype Namespace = Record<string, string>;\ntype NamespacedTranslations = Record<string, Namespace>;\ntype LanguageMap = Partial<Record<Language, NamespacedTranslations>>;\n\ninterface LanguageContextProps {\n  language: Language;\n  setLanguage: (lang: Language) => void;\n  t: (key: string, fallback?: string) => string;\n}\n\ninterface LanguageProviderProps {\n  children: ReactNode;\n  languageMap: LanguageMap;\n  defaultLanguage?: Language;\n  persist?: boolean;\n}\n\nconst LanguageContext = createContext<LanguageContextProps | undefined>(\n  undefined\n);\n\nconst LANGUAGE_STORAGE_KEY = 'app_language';\n\nexport const LanguageProvider: FC<LanguageProviderProps> = ({\n  children,\n  languageMap,\n  defaultLanguage = Language.English,\n  persist = true,\n}) => {\n  const getInitialLanguage = (): Language => {\n    if (persist && typeof localStorage !== 'undefined') {\n      const stored = localStorage.getItem(LANGUAGE_STORAGE_KEY);\n      if (stored && stored in Language) return stored as Language;\n    }\n\n    const browserLang = navigator.language.split('-')[0] as Language;\n    return browserLang in Language ? browserLang : defaultLanguage;\n  };\n\n  const [language, setLanguage] = useState<Language>(getInitialLanguage);\n\n  const setLanguageToLocalStorage = (lang: Language) => {\n    setLanguage(lang);\n    if (persist) localStorage.setItem(LANGUAGE_STORAGE_KEY, lang);\n  };\n\n  const translations = useMemo(\n    () => languageMap[language] ?? {},\n    [language, languageMap]\n  );\n\n  const t = useCallback(\n    (nsKey: string, key?: string, fallback?: string): string => {\n      let ns: string;\n      let actualKey: string;\n\n      // Support t(\"common.greeting\") and t(\"common\", \"greeting\")\n      if (key) {\n        ns = nsKey;\n        actualKey = key;\n      } else {\n        const parts = nsKey.split('.');\n        ns = parts[0];\n        actualKey = parts.slice(1).join('.');\n      }\n\n      const namespace = translations[ns];\n      const value = namespace?.[actualKey];\n\n      if (!value) {\n        console.warn(\n          `Missing translation for \"${ns}.${actualKey}\" in language \"${language}\"`\n        );\n      }\n\n      return value ?? fallback ?? actualKey;\n    },\n    [translations, language]\n  );\n\n  const value = useMemo(\n    () => ({\n      language,\n      setLanguage: setLanguageToLocalStorage,\n      t,\n    }),\n    [language, setLanguageToLocalStorage, t]\n  );\n\n  return (\n    <LanguageContext.Provider value={value}>\n      {children}\n    </LanguageContext.Provider>\n  );\n};\n\nexport const useLanguage = () => {\n  const context = useContext(LanguageContext);\n  if (!context)\n    throw new Error('useLanguage must be used within a LanguageProvider');\n  return context;\n};\n\nexport const useTranslation = () => {\n  const context = useLanguage();\n  return context.t;\n};\n"},{"id":"ModalContext","group":"context","name":"ModalContext","emoji":"ü™ü","code":"import React, {\n  createContext,\n  useCallback,\n  useContext,\n  useMemo,\n  useState,\n} from 'react';\n\ntype ModalContextType = {\n  isOpen: boolean;\n  modalContent: React.ReactNode | null;\n  openModal: (content: React.ReactNode) => void;\n  closeModal: () => void;\n};\n\nconst ModalContext = createContext<ModalContextType | undefined>(undefined);\n\nexport const ModalProvider: React.FC<{ children: React.ReactNode }> = ({\n  children,\n}) => {\n  const [isOpen, setIsOpen] = useState(false);\n  const [modalContent, setModalContent] = useState<React.ReactNode | null>(\n    null\n  );\n\n  const openModal = useCallback((content: React.ReactNode) => {\n    setModalContent(content);\n    setIsOpen(true);\n  }, []);\n\n  const closeModal = useCallback(() => {\n    setIsOpen(false);\n    setModalContent(null);\n  }, []);\n\n  const value = useMemo(\n    () => ({ isOpen, modalContent, openModal, closeModal }),\n    [isOpen, modalContent, openModal, closeModal]\n  );\n\n  return (\n    <ModalContext.Provider value={value}>{children}</ModalContext.Provider>\n  );\n};\n\nexport const useModal = (): ModalContextType => {\n  const context = useContext(ModalContext);\n  if (!context) {\n    throw new Error('useModal must be used within a ModalProvider');\n  }\n  return context;\n};\n"},{"id":"NotificationContext","group":"context","name":"NotificationContext","emoji":"üîî","code":"import {\n  createContext,\n  ReactNode,\n  useContext,\n  useEffect,\n  useMemo,\n  useRef,\n  useState,\n} from 'react';\n\nexport enum NotificationType {\n  Info = 'info',\n  Success = 'success',\n  Warning = 'warning',\n  Error = 'error',\n}\n\nexport interface Notification {\n  id: string;\n  type: NotificationType;\n  message: string;\n  title?: string;\n  dismissible: boolean;\n}\n\ninterface NotificationContextProps {\n  notifications: Notification[];\n  addNotification: (\n    type: NotificationType,\n    message: string,\n    options?: {\n      title?: string;\n      dismissible?: boolean;\n      timeout?: number;\n    }\n  ) => string;\n  removeNotification: (id: string) => void;\n}\n\nconst NotificationContext = createContext<NotificationContextProps | undefined>(\n  undefined\n);\n\nexport const NotificationProvider = ({ children }: { children: ReactNode }) => {\n  const [notifications, setNotifications] = useState<Notification[]>([]);\n  const timeoutRefs = useRef<Record<string, NodeJS.Timeout>>({});\n\n  useEffect(() => {\n    return () => {\n      Object.values(timeoutRefs.current).forEach(clearTimeout);\n    };\n  }, []);\n\n  const removeNotification = (id: string) => {\n    setNotifications((prev) => prev.filter((n) => n.id !== id));\n    const ref = timeoutRefs.current[id];\n    if (ref) {\n      clearTimeout(ref);\n      delete timeoutRefs.current[id];\n    }\n  };\n\n  const addNotification = (\n    type: NotificationType,\n    message: string,\n    options?: {\n      title?: string;\n      dismissible?: boolean;\n      timeout?: number;\n    }\n  ): string => {\n    const id = crypto.randomUUID();\n    const { title, dismissible = true, timeout = 3000 } = options ?? {};\n\n    const notification: Notification = {\n      id,\n      type,\n      message,\n      title,\n      dismissible,\n    };\n\n    setNotifications((prev) => {\n      const exists = prev.some((n) => n.message === message && n.type === type);\n      return exists ? prev : [...prev, notification];\n    });\n\n    timeoutRefs.current[id] = setTimeout(() => {\n      removeNotification(id);\n    }, timeout);\n\n    return id;\n  };\n\n  const value = useMemo(\n    () => ({\n      notifications,\n      addNotification,\n      removeNotification,\n    }),\n    [notifications]\n  );\n\n  return (\n    <NotificationContext.Provider value={value}>\n      {children}\n    </NotificationContext.Provider>\n  );\n};\n\nexport const useNotification = (): NotificationContextProps => {\n  const context = useContext(NotificationContext);\n  if (!context)\n    throw new Error(\n      'useNotification must be used within a NotificationProvider'\n    );\n  return context;\n};\n"},{"id":"SettingsContext","group":"context","name":"SettingsContext","emoji":"‚öôÔ∏è","code":"import React, {\n  createContext,\n  useState,\n  useCallback,\n  useMemo,\n  useContext,\n} from 'react';\n\ntype Settings = {\n  darkMode: boolean;\n  compactMode: boolean;\n  language: string;\n};\n\ntype SettingsContextType = {\n  settings: Settings;\n  updateSetting: <K extends keyof Settings>(key: K, value: Settings[K]) => void;\n  resetSettings: () => void;\n};\n\nconst defaultSettings: Settings = {\n  darkMode: false,\n  compactMode: false,\n  language: 'en',\n};\n\nconst SettingsContext = createContext<SettingsContextType | undefined>(\n  undefined\n);\n\nexport const SettingsProvider: React.FC<{ children: React.ReactNode }> = ({\n  children,\n}) => {\n  const [settings, setSettings] = useState<Settings>(defaultSettings);\n\n  const updateSetting = useCallback(\n    <K extends keyof Settings>(key: K, value: Settings[K]) => {\n      setSettings((prev) => ({ ...prev, [key]: value }));\n    },\n    []\n  );\n\n  const resetSettings = useCallback(() => {\n    setSettings(defaultSettings);\n  }, []);\n\n  const value = useMemo(\n    () => ({ settings, updateSetting, resetSettings }),\n    [settings, updateSetting, resetSettings]\n  );\n\n  return (\n    <SettingsContext.Provider value={value}>\n      {children}\n    </SettingsContext.Provider>\n  );\n};\n\nexport const useSettings = (): SettingsContextType => {\n  const context = useContext(SettingsContext);\n  if (!context) {\n    throw new Error('useSettings must be used within a SettingsProvider');\n  }\n  return context;\n};\n"},{"id":"ThemeContext","group":"context","name":"ThemeContext","emoji":"üé®","code":"import {\n  createContext,\n  useContext,\n  useEffect,\n  useState,\n  ReactNode,\n  useMemo,\n} from 'react';\n\ntype Theme = 'light' | 'dark';\n\ninterface ThemeContextProps {\n  theme: Theme;\n  toggleTheme: () => void;\n  setTheme: (theme: Theme) => void;\n}\n\nconst ThemeContext = createContext<ThemeContextProps | undefined>(undefined);\n\nexport const ThemeProvider = ({ children }: { children: ReactNode }) => {\n  const [theme, setTheme] = useState<Theme>('light');\n\n  useEffect(() => {\n    const savedTheme = localStorage.getItem('theme') as Theme | null;\n    if (savedTheme) {\n      setTheme(savedTheme);\n    } else {\n      const prefersDark = window.matchMedia(\n        '(prefers-color-scheme: dark)'\n      ).matches;\n      setTheme(prefersDark ? 'dark' : 'light');\n    }\n  }, []);\n\n  useEffect(() => {\n    document.documentElement.classList.toggle('dark', theme === 'dark');\n    localStorage.setItem('theme', theme);\n  }, [theme]);\n\n  const toggleTheme = () => {\n    setTheme((prev) => (prev === 'light' ? 'dark' : 'light'));\n  };\n\n  const value = useMemo(() => ({ theme, toggleTheme, setTheme }), [theme]);\n\n  return (\n    <ThemeContext.Provider value={value}>{children}</ThemeContext.Provider>\n  );\n};\n\nexport const useTheme = () => {\n  const context = useContext(ThemeContext);\n  if (!context) throw new Error('useTheme must be used within a ThemeProvider');\n  return context;\n};\n"},{"id":"UserContext","group":"context","name":"UserContext","emoji":"üë§","code":"import { trpcClient } from '@start/utils/trpc';\nimport {\n\tcreateContext,\n\tFC,\n\tReactNode,\n\tuseContext,\n\tuseEffect,\n\tuseMemo,\n\tuseState,\n} from 'react';\n\ninterface User {\n\temail: string;\n}\n\ninterface UserContextValue {\n\tisAuthenticated: boolean;\n\tisLoading: boolean;\n\tuser: User | null;\n\trefresh: () => Promise<void>;\n\tsignOut: () => Promise<void>;\n}\n\nconst UserContext = createContext<UserContextValue | undefined>(undefined);\n\nexport const UserProvider: FC<{ children: ReactNode }> = ({\n\tchildren,\n}: {\n\tchildren: ReactNode;\n}) => {\n\tconst [\n\t\t{ isAuthenticated = false, isLoading = false, user = null },\n\t\tsetState,\n\t] = useState<{\n\t\tisAuthenticated: boolean;\n\t\tisLoading: boolean;\n\t\tuser: User | null;\n\t}>({\n\t\tisAuthenticated: false,\n\t\tisLoading: false,\n\t\tuser: null,\n\t});\n\n\tconst getUser = async () => {\n\t\tsetState((previous) => ({ ...previous, isLoading: true }));\n\t\ttry {\n\t\t\tconst { user } = await trpcClient.app.user.get.query();\n\t\t\tsetState((previous) => ({ ...previous, isAuthenticated: true, user }));\n\t\t} catch (err) {\n\t\t\tconsole.error(err);\n\t\t\tsetState((previous) => ({\n\t\t\t\t...previous,\n\t\t\t\tisAuthenticated: false,\n\t\t\t\tuser: null,\n\t\t\t}));\n\t\t} finally {\n\t\t\tsetState((previous) => ({ ...previous, isLoading: false }));\n\t\t}\n\t};\n\n\tconst signOut = async () => {\n\t\ttry {\n\t\t\tconst { success } = await trpcClient.auth.user.signOut.mutate();\n\t\t\tif (success) {\n\t\t\t\talert('Sign Out Successfully');\n\t\t\t\tsetState((previous) => ({\n\t\t\t\t\t...previous,\n\t\t\t\t\tisAuthenticated: false,\n\t\t\t\t\tuser: null,\n\t\t\t\t}));\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tconsole.error(error);\n\t\t}\n\t};\n\n\tuseEffect(() => {\n\t\tgetUser();\n\t}, []);\n\n\t// ‚úÖ FIX: Memoize the value to keep it referentially stable\n\tconst value = useMemo(\n\t\t() => ({\n\t\t\tisAuthenticated,\n\t\t\tisLoading,\n\t\t\tuser,\n\t\t\trefresh: getUser,\n\t\t\tsignOut,\n\t\t}),\n\t\t[isAuthenticated, isLoading, user, getUser, signOut],\n\t);\n\n\treturn <UserContext.Provider value={value}>{children}</UserContext.Provider>;\n};\n\nexport function useUser() {\n\tconst context = useContext(UserContext);\n\tif (!context) {\n\t\tthrow new Error('useUser must be used within a UserProvider');\n\t}\n\treturn context;\n}\n"}]},"__N_SSG":true}